//
// Generated file, do not edit! Created by opp_msgc 4.3 from transport/tcp/TCPSegment.msg.
//

#ifndef _TCPSEGMENT_M_H_
#define _TCPSEGMENT_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0403
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include <iostream>
#include "INETDefs.h"

    
    #define TCP_HEADER_OCTETS  20    

    
    const unsigned int TCP_MAX_HEADER_OCTETS = 60;

    
    const unsigned int MAX_SACK_ENTRIES = 4;

    typedef cPacket *cPacketPtr;

    inline std::ostream& operator<<(std::ostream& os, cPacketPtr msg)
    {
        return os << "(" << msg->getClassName() << ") " << msg->getName() << ": " << msg->info();
    }

    inline void doPacking(cCommBuffer *b, cPacketPtr& msg) {msg->parsimPack(b);}
    inline void doUnpacking(cCommBuffer *b, cPacketPtr& msg) {msg->parsimUnpack(b);}
// }}



/**
 * Enum generated from <tt>transport/tcp/TCPSegment.msg</tt> by opp_msgc.
 * <pre>
 * enum TCPOptionNumbers
 * {
 *     TCPOPTION_END_OF_OPTION_LIST = 0;                   
 *     TCPOPTION_NO_OPERATION = 1;                         
 *     TCPOPTION_MAXIMUM_SEGMENT_SIZE = 2;                 
 *     TCPOPTION_WINDOW_SCALE = 3;                         
 *     TCPOPTION_SACK_PERMITTED = 4;                       
 *     TCPOPTION_SACK = 5;                                 
 * 
 * 
 *     TCPOPTION_TIMESTAMP = 8;                            
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * };
 * </pre>
 */
enum TCPOptionNumbers {
    TCPOPTION_END_OF_OPTION_LIST = 0,
    TCPOPTION_NO_OPERATION = 1,
    TCPOPTION_MAXIMUM_SEGMENT_SIZE = 2,
    TCPOPTION_WINDOW_SCALE = 3,
    TCPOPTION_SACK_PERMITTED = 4,
    TCPOPTION_SACK = 5,
    TCPOPTION_TIMESTAMP = 8
};

/**
 * Struct generated from transport/tcp/TCPSegment.msg by opp_msgc.
 */
struct TCPPayloadMessage
{
    TCPPayloadMessage();
    unsigned int endSequenceNo;
    cPacketPtr msg;
};

void doPacking(cCommBuffer *b, TCPPayloadMessage& a);
void doUnpacking(cCommBuffer *b, TCPPayloadMessage& a);

/**
 * Class generated from <tt>transport/tcp/TCPSegment.msg</tt> by opp_msgc.
 * <pre>
 * class Sack
 * {
 *     unsigned int start;     
 *     unsigned int end;       
 * }
 * </pre>
 */
class Sack : public ::cObject
{
  protected:
    unsigned int start_var;
    unsigned int end_var;

  private:
    void copy(const Sack& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Sack&);

  public:
    Sack();
    Sack(const Sack& other);
    virtual ~Sack();
    Sack& operator=(const Sack& other);
    virtual Sack *dup() const {return new Sack(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getStart() const;
    virtual void setStart(unsigned int start);
    virtual unsigned int getEnd() const;
    virtual void setEnd(unsigned int end);
};

inline void doPacking(cCommBuffer *b, Sack& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Sack& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transport/tcp/TCPSegment.msg</tt> by opp_msgc.
 * <pre>
 * class TCPOption
 * {
 *     unsigned short kind enum(TCPOptionNumbers) = TCPOPTION_END_OF_OPTION_LIST;  
 *     unsigned short length = 1;                          
 *     unsigned int values[];                              
 * }
 * </pre>
 */
class TCPOption : public ::cObject
{
  protected:
    unsigned short kind_var;
    unsigned short length_var;
    unsigned int *values_var; // array ptr
    unsigned int values_arraysize;

  private:
    void copy(const TCPOption& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const TCPOption&);

  public:
    TCPOption();
    TCPOption(const TCPOption& other);
    virtual ~TCPOption();
    TCPOption& operator=(const TCPOption& other);
    virtual TCPOption *dup() const {return new TCPOption(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getKind() const;
    virtual void setKind(unsigned short kind);
    virtual unsigned short getLength() const;
    virtual void setLength(unsigned short length);
    virtual void setValuesArraySize(unsigned int size);
    virtual unsigned int getValuesArraySize() const;
    virtual unsigned int getValues(unsigned int k) const;
    virtual void setValues(unsigned int k, unsigned int values);
};

inline void doPacking(cCommBuffer *b, TCPOption& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, TCPOption& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transport/tcp/TCPSegment.msg</tt> by opp_msgc.
 * <pre>
 * packet TCPSegment
 * {
 *     @customize(true);
 *     
 *     unsigned short srcPort;
 * 
 *     
 *     unsigned short destPort;
 * 
 *     
 *     
 *     
 *     
 *     unsigned int sequenceNo;
 * 
 *     
 *     
 *     
 *     unsigned int ackNo;
 * 
 *     
 *     
 *     unsigned short headerLength = TCP_HEADER_OCTETS; 
 * 
 *     bool urgBit; 
 *     bool ackBit; 
 *     bool pshBit; 
 *     bool rstBit; 
 *     bool synBit; 
 *     bool finBit; 
 * 
 *     
 *     
 *     
 *     unsigned short window;
 * 
 *     
 *     
 *     
 *     
 *     
 *     unsigned short urgentPointer;
 * 
 *     
 *     
 *     TCPOption options[];
 * 
 *     
 *     
 *     
 *     
 *     unsigned long payloadLength;
 * 
 *     
 *     
 *     
 *     
 *     
 *     
 *     
 *     
 *     
 *     abstract TCPPayloadMessage payload[];
 * }
 * </pre>
 *
 * TCPSegment_Base is only useful if it gets subclassed, and TCPSegment is derived from it.
 * The minimum code to be written for TCPSegment is the following:
 *
 * <pre>
 * class TCPSegment : public TCPSegment_Base
 * {
 *   private:
 *     void copy(const TCPSegment& other) { ... }

 *   public:
 *     TCPSegment(const char *name=NULL, int kind=0) : TCPSegment_Base(name,kind) {}
 *     TCPSegment(const TCPSegment& other) : TCPSegment_Base(other) {copy(other);}
 *     TCPSegment& operator=(const TCPSegment& other) {if (this==&other) return *this; TCPSegment_Base::operator=(other); copy(other); return *this;}
 *     virtual TCPSegment *dup() const {return new TCPSegment(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from TCPSegment_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(TCPSegment);
 * </pre>
 */
class TCPSegment_Base : public ::cPacket
{
  protected:
    unsigned short srcPort_var;
    unsigned short destPort_var;
    unsigned int sequenceNo_var;
    unsigned int ackNo_var;
    unsigned short headerLength_var;
    bool urgBit_var;
    bool ackBit_var;
    bool pshBit_var;
    bool rstBit_var;
    bool synBit_var;
    bool finBit_var;
    unsigned short window_var;
    unsigned short urgentPointer_var;
    TCPOption *options_var; // array ptr
    unsigned int options_arraysize;
    unsigned long payloadLength_var;

  private:
    void copy(const TCPSegment_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const TCPSegment_Base&);
    // make constructors protected to avoid instantiation
    TCPSegment_Base(const char *name=NULL, int kind=0);
    TCPSegment_Base(const TCPSegment_Base& other);
    // make assignment operator protected to force the user override it
    TCPSegment_Base& operator=(const TCPSegment_Base& other);

  public:
    virtual ~TCPSegment_Base();
    virtual TCPSegment_Base *dup() const {throw cRuntimeError("You forgot to manually add a dup() function to class TCPSegment");}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getSrcPort() const;
    virtual void setSrcPort(unsigned short srcPort);
    virtual unsigned short getDestPort() const;
    virtual void setDestPort(unsigned short destPort);
    virtual unsigned int getSequenceNo() const;
    virtual void setSequenceNo(unsigned int sequenceNo);
    virtual unsigned int getAckNo() const;
    virtual void setAckNo(unsigned int ackNo);
    virtual unsigned short getHeaderLength() const;
    virtual void setHeaderLength(unsigned short headerLength);
    virtual bool getUrgBit() const;
    virtual void setUrgBit(bool urgBit);
    virtual bool getAckBit() const;
    virtual void setAckBit(bool ackBit);
    virtual bool getPshBit() const;
    virtual void setPshBit(bool pshBit);
    virtual bool getRstBit() const;
    virtual void setRstBit(bool rstBit);
    virtual bool getSynBit() const;
    virtual void setSynBit(bool synBit);
    virtual bool getFinBit() const;
    virtual void setFinBit(bool finBit);
    virtual unsigned short getWindow() const;
    virtual void setWindow(unsigned short window);
    virtual unsigned short getUrgentPointer() const;
    virtual void setUrgentPointer(unsigned short urgentPointer);
    virtual void setOptionsArraySize(unsigned int size);
    virtual unsigned int getOptionsArraySize() const;
    virtual TCPOption& getOptions(unsigned int k);
    virtual const TCPOption& getOptions(unsigned int k) const {return const_cast<TCPSegment_Base*>(this)->getOptions(k);}
    virtual void setOptions(unsigned int k, const TCPOption& options);
    virtual unsigned long getPayloadLength() const;
    virtual void setPayloadLength(unsigned long payloadLength);
    virtual void setPayloadArraySize(unsigned int size) = 0;
    virtual unsigned int getPayloadArraySize() const = 0;
    virtual TCPPayloadMessage& getPayload(unsigned int k) = 0;
    virtual const TCPPayloadMessage& getPayload(unsigned int k) const {return const_cast<TCPSegment_Base*>(this)->getPayload(k);}
    virtual void setPayload(unsigned int k, const TCPPayloadMessage& payload) = 0;
};


#endif // _TCPSEGMENT_M_H_
