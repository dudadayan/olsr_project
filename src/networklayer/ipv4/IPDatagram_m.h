//
// Generated file, do not edit! Created by opp_msgc 4.3 from networklayer/ipv4/IPDatagram.msg.
//

#ifndef _IPDATAGRAM_M_H_
#define _IPDATAGRAM_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0403
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include "IPAddress.h"
#include "IPProtocolId_m.h"


const int IP_HEADER_BYTES = 20;


const int IP_MAX_HEADER_BYTES = 60;


const unsigned int MAX_IPADDR_OPTION_ENTRIES = 9;
const unsigned int MAX_TIMESTAMP_OPTION_ENTRIES = 4;
// }}



/**
 * Enum generated from <tt>networklayer/ipv4/IPDatagram.msg</tt> by opp_msgc.
 * <pre>
 * enum IPOptionClass
 * {
 *     IPOPTION_CLASS_CONTROL = 0;
 *     IPOPTION_CLASS_RESERVED = 1;
 *     IPOPTION_CLASS_DEBUGGING = 2;
 *     IPOPTION_CLASS_RESERVED2 = 3;
 * };
 * </pre>
 */
enum IPOptionClass {
    IPOPTION_CLASS_CONTROL = 0,
    IPOPTION_CLASS_RESERVED = 1,
    IPOPTION_CLASS_DEBUGGING = 2,
    IPOPTION_CLASS_RESERVED2 = 3
};

/**
 * Enum generated from <tt>networklayer/ipv4/IPDatagram.msg</tt> by opp_msgc.
 * <pre>
 * enum IPOption
 * {
 *     IPOPTION_END_OF_OPTIONS = 0;
 *     IPOPTION_NO_OPTION = 1;
 *     IPOPTION_SECURITY = 2;
 *     IPOPTION_LOOSE_SOURCE_ROUTING = 3;
 *     IPOPTION_TIMESTAMP = 4;
 *     IPOPTION_RECORD_ROUTE = 7;
 *     IPOPTION_STREAM_ID = 8;
 *     IPOPTION_STRICT_SOURCE_ROUTING = 9;
 *     IPOPTION_ROUTER_ALERT = 20;
 * };
 * </pre>
 */
enum IPOption {
    IPOPTION_END_OF_OPTIONS = 0,
    IPOPTION_NO_OPTION = 1,
    IPOPTION_SECURITY = 2,
    IPOPTION_LOOSE_SOURCE_ROUTING = 3,
    IPOPTION_TIMESTAMP = 4,
    IPOPTION_RECORD_ROUTE = 7,
    IPOPTION_STREAM_ID = 8,
    IPOPTION_STRICT_SOURCE_ROUTING = 9,
    IPOPTION_ROUTER_ALERT = 20
};

/**
 * Enum generated from <tt>networklayer/ipv4/IPDatagram.msg</tt> by opp_msgc.
 * <pre>
 * enum TimestampFlag
 * {
 *     IP_TIMESTAMP_TIMESTAMP_ONLY = 0;
 *     IP_TIMESTAMP_WITH_ADDRESS = 1;
 *     IP_TIMESTAMP_SENDER_INIT_ADDRESS = 3;
 * }
 * </pre>
 */
enum TimestampFlag {
    IP_TIMESTAMP_TIMESTAMP_ONLY = 0,
    IP_TIMESTAMP_WITH_ADDRESS = 1,
    IP_TIMESTAMP_SENDER_INIT_ADDRESS = 3
};

/**
 * Class generated from <tt>networklayer/ipv4/IPDatagram.msg</tt> by opp_msgc.
 * <pre>
 * class IPRecordRouteOption
 * {
 *     IPAddress recordAddress[MAX_IPADDR_OPTION_ENTRIES];
 *     short nextAddressPtr;
 * }
 * </pre>
 */
class IPRecordRouteOption : public ::cObject
{
  protected:
    IPAddress recordAddress_var[MAX_IPADDR_OPTION_ENTRIES];
    short nextAddressPtr_var;

  private:
    void copy(const IPRecordRouteOption& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IPRecordRouteOption&);

  public:
    IPRecordRouteOption();
    IPRecordRouteOption(const IPRecordRouteOption& other);
    virtual ~IPRecordRouteOption();
    IPRecordRouteOption& operator=(const IPRecordRouteOption& other);
    virtual IPRecordRouteOption *dup() const {return new IPRecordRouteOption(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getRecordAddressArraySize() const;
    virtual IPAddress& getRecordAddress(unsigned int k);
    virtual const IPAddress& getRecordAddress(unsigned int k) const {return const_cast<IPRecordRouteOption*>(this)->getRecordAddress(k);}
    virtual void setRecordAddress(unsigned int k, const IPAddress& recordAddress);
    virtual short getNextAddressPtr() const;
    virtual void setNextAddressPtr(short nextAddressPtr);
};

inline void doPacking(cCommBuffer *b, IPRecordRouteOption& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IPRecordRouteOption& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/ipv4/IPDatagram.msg</tt> by opp_msgc.
 * <pre>
 * class IPTimestampOption
 * {
 *     int flag enum(TimestampFlag);
 *     short overflow;
 *     short nextAddressPtr;
 * 
 *     
 *     
 *     IPAddress recordAddress[MAX_TIMESTAMP_OPTION_ENTRIES];
 *     simtime_t recordTimestamp[MAX_IPADDR_OPTION_ENTRIES];
 * }
 * </pre>
 */
class IPTimestampOption : public ::cObject
{
  protected:
    int flag_var;
    short overflow_var;
    short nextAddressPtr_var;
    IPAddress recordAddress_var[MAX_TIMESTAMP_OPTION_ENTRIES];
    simtime_t recordTimestamp_var[MAX_IPADDR_OPTION_ENTRIES];

  private:
    void copy(const IPTimestampOption& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IPTimestampOption&);

  public:
    IPTimestampOption();
    IPTimestampOption(const IPTimestampOption& other);
    virtual ~IPTimestampOption();
    IPTimestampOption& operator=(const IPTimestampOption& other);
    virtual IPTimestampOption *dup() const {return new IPTimestampOption(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getFlag() const;
    virtual void setFlag(int flag);
    virtual short getOverflow() const;
    virtual void setOverflow(short overflow);
    virtual short getNextAddressPtr() const;
    virtual void setNextAddressPtr(short nextAddressPtr);
    virtual unsigned int getRecordAddressArraySize() const;
    virtual IPAddress& getRecordAddress(unsigned int k);
    virtual const IPAddress& getRecordAddress(unsigned int k) const {return const_cast<IPTimestampOption*>(this)->getRecordAddress(k);}
    virtual void setRecordAddress(unsigned int k, const IPAddress& recordAddress);
    virtual unsigned int getRecordTimestampArraySize() const;
    virtual simtime_t getRecordTimestamp(unsigned int k) const;
    virtual void setRecordTimestamp(unsigned int k, simtime_t recordTimestamp);
};

inline void doPacking(cCommBuffer *b, IPTimestampOption& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IPTimestampOption& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/ipv4/IPDatagram.msg</tt> by opp_msgc.
 * <pre>
 * class IPSourceRoutingOption
 * {
 *     IPAddress recordAddress[MAX_IPADDR_OPTION_ENTRIES];
 *     short nextAddressPtr;
 *     short lastAddressPtr;
 * }
 * </pre>
 */
class IPSourceRoutingOption : public ::cObject
{
  protected:
    IPAddress recordAddress_var[MAX_IPADDR_OPTION_ENTRIES];
    short nextAddressPtr_var;
    short lastAddressPtr_var;

  private:
    void copy(const IPSourceRoutingOption& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IPSourceRoutingOption&);

  public:
    IPSourceRoutingOption();
    IPSourceRoutingOption(const IPSourceRoutingOption& other);
    virtual ~IPSourceRoutingOption();
    IPSourceRoutingOption& operator=(const IPSourceRoutingOption& other);
    virtual IPSourceRoutingOption *dup() const {return new IPSourceRoutingOption(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getRecordAddressArraySize() const;
    virtual IPAddress& getRecordAddress(unsigned int k);
    virtual const IPAddress& getRecordAddress(unsigned int k) const {return const_cast<IPSourceRoutingOption*>(this)->getRecordAddress(k);}
    virtual void setRecordAddress(unsigned int k, const IPAddress& recordAddress);
    virtual short getNextAddressPtr() const;
    virtual void setNextAddressPtr(short nextAddressPtr);
    virtual short getLastAddressPtr() const;
    virtual void setLastAddressPtr(short lastAddressPtr);
};

inline void doPacking(cCommBuffer *b, IPSourceRoutingOption& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IPSourceRoutingOption& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/ipv4/IPDatagram.msg</tt> by opp_msgc.
 * <pre>
 * packet IPDatagram
 * {
 *     short version = 4;
 *     short headerLength = IP_HEADER_BYTES;
 * 
 *     IPAddress srcAddress;
 *     IPAddress destAddress;
 * 
 *     int transportProtocol enum(IPProtocolId) = IP_PROT_NONE;
 *     short timeToLive;
 *     int identification;
 *     bool moreFragments;
 *     bool dontFragment;
 *     int fragmentOffset;
 *     unsigned char diffServCodePoint;
 * 
 *     int optionCode enum(IPOption) = IPOPTION_NO_OPTION;  
 *                                                          
 *     IPRecordRouteOption recordRoute;
 *     IPTimestampOption timestampOption;
 *     IPSourceRoutingOption sourceRoutingOption; 
 *     
 *     
 *     unsigned int totalPayloadLength;
 * }
 * </pre>
 */
class IPDatagram : public ::cPacket
{
  protected:
    short version_var;
    short headerLength_var;
    IPAddress srcAddress_var;
    IPAddress destAddress_var;
    int transportProtocol_var;
    short timeToLive_var;
    int identification_var;
    bool moreFragments_var;
    bool dontFragment_var;
    int fragmentOffset_var;
    unsigned char diffServCodePoint_var;
    int optionCode_var;
    IPRecordRouteOption recordRoute_var;
    IPTimestampOption timestampOption_var;
    IPSourceRoutingOption sourceRoutingOption_var;
    unsigned int totalPayloadLength_var;

  private:
    void copy(const IPDatagram& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IPDatagram&);

  public:
    IPDatagram(const char *name=NULL, int kind=0);
    IPDatagram(const IPDatagram& other);
    virtual ~IPDatagram();
    IPDatagram& operator=(const IPDatagram& other);
    virtual IPDatagram *dup() const {return new IPDatagram(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual short getVersion() const;
    virtual void setVersion(short version);
    virtual short getHeaderLength() const;
    virtual void setHeaderLength(short headerLength);
    virtual IPAddress& getSrcAddress();
    virtual const IPAddress& getSrcAddress() const {return const_cast<IPDatagram*>(this)->getSrcAddress();}
    virtual void setSrcAddress(const IPAddress& srcAddress);
    virtual IPAddress& getDestAddress();
    virtual const IPAddress& getDestAddress() const {return const_cast<IPDatagram*>(this)->getDestAddress();}
    virtual void setDestAddress(const IPAddress& destAddress);
    virtual int getTransportProtocol() const;
    virtual void setTransportProtocol(int transportProtocol);
    virtual short getTimeToLive() const;
    virtual void setTimeToLive(short timeToLive);
    virtual int getIdentification() const;
    virtual void setIdentification(int identification);
    virtual bool getMoreFragments() const;
    virtual void setMoreFragments(bool moreFragments);
    virtual bool getDontFragment() const;
    virtual void setDontFragment(bool dontFragment);
    virtual int getFragmentOffset() const;
    virtual void setFragmentOffset(int fragmentOffset);
    virtual unsigned char getDiffServCodePoint() const;
    virtual void setDiffServCodePoint(unsigned char diffServCodePoint);
    virtual int getOptionCode() const;
    virtual void setOptionCode(int optionCode);
    virtual IPRecordRouteOption& getRecordRoute();
    virtual const IPRecordRouteOption& getRecordRoute() const {return const_cast<IPDatagram*>(this)->getRecordRoute();}
    virtual void setRecordRoute(const IPRecordRouteOption& recordRoute);
    virtual IPTimestampOption& getTimestampOption();
    virtual const IPTimestampOption& getTimestampOption() const {return const_cast<IPDatagram*>(this)->getTimestampOption();}
    virtual void setTimestampOption(const IPTimestampOption& timestampOption);
    virtual IPSourceRoutingOption& getSourceRoutingOption();
    virtual const IPSourceRoutingOption& getSourceRoutingOption() const {return const_cast<IPDatagram*>(this)->getSourceRoutingOption();}
    virtual void setSourceRoutingOption(const IPSourceRoutingOption& sourceRoutingOption);
    virtual unsigned int getTotalPayloadLength() const;
    virtual void setTotalPayloadLength(unsigned int totalPayloadLength);
};

inline void doPacking(cCommBuffer *b, IPDatagram& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, IPDatagram& obj) {obj.parsimUnpack(b);}


#endif // _IPDATAGRAM_M_H_
